<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" href="style.css">
<meta charset="utf-8"/>
<title>League History</title>
<h2 style="font-size: 1.2em; color: #4a5568; margin-bottom: 20px;">
  None of us are as dumb as all of us
</h2>
<style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    h1 { text-align: center; }
    details { margin-bottom: 20px; }
    summary { font-size: 1.2em; font-weight: bold; cursor: pointer; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; cursor: pointer; }
    #survivor-list {
    list-style: none;
    padding: 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  #survivor-list li {
    background-color: #edf2f7; /* light gray-blue */
    color: #2d3748;            /* dark gray text */
    border-radius: 20px;
    padding: 6px 12px;
    font-size: 0.9em;
    border: 1px solid #cbd5e0;
  }
</style>
</head>
<body>
  <div>
    <button onclick="showTab('history-tab')">League History</button>
    <button onclick="showTab('h2h-tab')">Head to Head</button>
    <button onclick="showTab('records-tab')">All-Time Records</button>
    <button onclick="showTab('habits-tab')">Owner Habits</button>
    <button onclick="showTab('advanced-tab')">Advanced Metrics</button>
    <button onclick="showTab('summaries-tab')">Weekly Summaries</button>
  </div>
<div id="history-tab" style="display: block;">
  <h1>Who Dat League History</h1>
  <details open="">
    <summary>Overall Record by Owner (5+ Seasons)</summary>
    <table id="overall-table">
      <thead>
        <tr>
          <th>Owner Name</th>
          <th>Seasons</th>
          <th>Wins</th>
          <th>Losses</th>
          <th>Win %</th>
          <th>Point Diff</th>
          <th>League Championships</th>
          <th>Reg Season Championships</th>
          <th>Avg Reg Season Rank</th>
          <th>Sacko Titles</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </details>
  <h2>Season Records</h2><p><em>* = League Champion</em></p>
  <div id="tables-container"></div>
</div>

<div id="h2h-tab" style="display: none;">
  <h2>Head to Head Records</h2>
  <label for="owner-select">Select Owner:</label>
  <select id="owner-select" onchange="filterH2H()"></select>
  <table border="1" id="h2h-table">
    <thead>
      <tr><th>Opponent</th><th>Games Played</th><th>Wins</th><th>Losses</th><th>Ties</th><th>Points For</th><th>Points Against</th><th>Point Diff</th><th>Win %</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<div id="records-tab" style="display: none;">
    <h2>All-Time Records</h2>

    <label for="category-filter">Filter by Category:</label>
    <select id="category-filter">
      <option value="All">All</option>
      <option value="Team Game">Team Game</option>
      <option value="Single Game">Single Game</option>
    </select>
    
    <table id="records-table">
      <thead>
        <tr>
          <th>Category</th>
          <th>Record</th>
          <th>Owner</th>
          <th>Detail</th>
          <th>Points</th>
          <th>Year</th>
          <th>Week</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
</div>
        <div id="habits-tab" style="display: none;">
          <h2>Owner Habits â€“ Most Drafted Players</h2>
          <table id="habits-table">
            <thead>
              <tr>
                <th>Owner Name</th>
                <th>Most Drafted Player</th>
                <th>Times Drafted</th>
                <th>Drafted Seasons</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        
          <h2>Positional Contributions</h2>
          <details open>
            <summary>Overall Positional Breakdown by Owner</summary>
            <table id="position-overall-table">
              <thead>
                <tr>
                  <th>Owner</th>
                  <th>Total Points</th>
                  <th>QB %</th>
                  <th>RB %</th>
                  <th>WR %</th>
                  <th>TE %</th>
                  <th>K %</th>
                  <th>D/ST %</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </details>
        
          <div id="position-seasons-container"></div>
        </div>
        <div id="advanced-tab" style="display: none;">
          <h2>Advanced Team Metrics</h2>
        
          <details open>
            <summary>Overall Summary by Owner (Since 2019)</summary>
            <table id="advanced-overall-table">
              <thead>
                <tr>
                  <th>Owner</th>
                  <th>True W/L</th>
                  <th>True W/L %</th>
                  <th>Luck Index</th>
                  <th>Strength of Schedule</th>
                  <th>Manager Efficiency</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </details>
        
          <div id="advanced-seasons-container"></div>
        </div>
  <div id="summaries-tab" style="display: none;">
    <h2>Weekly Summaries</h2>
    <h3>Alive in Survivor</h3>
    <ul id="survivor-list" style="margin-bottom: 20px;"></ul>
    <h3>Summary Overview</h3>
<table id="weekly-summary-overview" style="margin-bottom: 20px;">
  <thead>
    <tr>
      <th>Owner</th>
      <th>Payouts Won</th>
      <th>Survivor Exit (Week)</th>
      <th>ðŸ”¥ Regression Plaques</th>
      <th>ðŸ§± Crawlspace Trophies</th>
      <th>ðŸ§  Clipboards</th>
    </tr>
  </thead>
  <tbody></tbody>
</table>
    <div id="summaries-container"></div>
</div>
<script>
function showTab(tabId) {
  const tabs = document.querySelectorAll("div[id$='-tab']");
  tabs.forEach(tab => tab.style.display = "none");
  document.getElementById(tabId).style.display = 'block';
}

function parseCSV(csv) {
  const lines = csv.trim().split("\n");
  const headers = lines[0].split(",");
  const rows = lines.slice(1).map(line => {
    const values = [];
    let current = '';
    let inQuotes = false;
    for (let char of line) {
      if (char === '"' && inQuotes) {
        inQuotes = false;
      } else if (char === '"' && !inQuotes) {
        inQuotes = true;
      } else if (char === ',' && !inQuotes) {
        values.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    values.push(current);
    return values;
  });
  return { headers, rows };
}

function makeTableSortable(table) {
  const headers = table.querySelectorAll("th");
  headers.forEach((th, index) => {
    th.addEventListener("click", () => sortTable(table, index));
  });
}

function sortTable(table, colIndex) {
  const tbody = table.querySelector("tbody");
  const rows = Array.from(tbody.querySelectorAll("tr"));
  const isNumeric = !isNaN(rows[0].children[colIndex].textContent.replace('%', ''));
  const currentOrder = table.getAttribute(`data-sort-dir-${colIndex}`) || "asc";
  const nextOrder = currentOrder === "asc" ? "desc" : "asc";

  rows.sort((a, b) => {
    let cellA = a.children[colIndex].textContent.replace('%', '');
    let cellB = b.children[colIndex].textContent.replace('%', '');
    if (isNumeric) {
      return (nextOrder === "asc" ? 1 : -1) * (parseFloat(cellA) - parseFloat(cellB));
    } else {
      return (nextOrder === "asc" ? 1 : -1) * cellA.localeCompare(cellB);
    }
  });

  table.setAttribute(`data-sort-dir-${colIndex}`, nextOrder);
  rows.forEach(row => tbody.appendChild(row));
}

fetch("league_history.csv")
  .then(res => res.text())
  .then(csv => {
    const { headers, rows } = parseCSV(csv);
    const index = {
      year: headers.indexOf("Year"),
      ownerId: headers.indexOf("Owner ID"),
      ownerName: headers.indexOf("Owner Name"),
      wins: headers.indexOf("Wins"),
      losses: headers.indexOf("Losses"),
      pf: headers.indexOf("Points For"),
      pa: headers.indexOf("Points Against"),
      standing: headers.indexOf("Final Standing"),
      sacko: headers.indexOf("Sacko"),
      champion: headers.indexOf("Champion")
    };

    const seasonMap = {}, ownerStats = {};

    for (let row of rows) {
      const year = row[index.year];
      if (!seasonMap[year]) seasonMap[year] = [];
      seasonMap[year].push(row);
    }

    for (const year in seasonMap) {
      const teams = seasonMap[year].map(row => {
        const wins = parseInt(row[index.wins]);
        const losses = parseInt(row[index.losses]);
        const pf = parseFloat(row[index.pf]);
        const wp = wins / (wins + losses);
        return { row, wins, losses, pf, wp };
      }).sort((a, b) => b.wp - a.wp || b.pf - a.pf);

      let championName = null;
      let sackoName = null;

      seasonMap[year].forEach(row => {
        if (row[index.champion] === "True") {
          championName = row[index.ownerName];
        }
        if (row[index.sacko] === "True") {
          sackoName = row[index.ownerName];
        }
      });

      teams.forEach((team, i) => {
        const row = team.row;
        const id = row[index.ownerId];
        const name = row[index.ownerName];
        const wins = team.wins, losses = team.losses;
        const pf = team.pf, pa = parseFloat(row[index.pa]);
        const final = parseInt(row[index.standing]), rank = i + 1;

        if (!ownerStats[id]) {
          ownerStats[id] = {
            sacko: 0, name, seasons: 0, wins: 0, losses: 0, pf: 0, pa: 0,
            champ: 0, regChamp: 0, regRankSum: 0
          };
        }

        const owner = ownerStats[id];
        owner.name = name;
        owner.seasons++;
        owner.wins += wins;
        owner.losses += losses;
        owner.pf += pf;
        owner.pa += pa;
        owner.regRankSum += rank;
        if (row[index.sacko] === "True") owner.sacko++;
        if (rank === 1) owner.regChamp++;
        if (final === 1) owner.champ++;
      });
    }

    const tbody = document.querySelector("#overall-table tbody");
    Object.values(ownerStats)
      .filter(o => o.seasons >= 5)
      .sort((a, b) => (b.wins / (b.wins + b.losses)) - (a.wins / (a.wins + a.losses)))
      .forEach(o => {
        const wp = o.wins / (o.wins + o.losses);
        const diff = o.pf - o.pa;
        const avgRank = o.regRankSum / o.seasons;
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${o.name}</td>
          <td>${o.seasons}</td>
          <td>${o.wins}</td>
          <td>${o.losses}</td>
          <td>${(wp * 100).toFixed(1)}%</td>
          <td>${diff.toFixed(1)}</td>
          <td>${o.champ}</td>
          <td>${o.regChamp}</td>
          <td>${avgRank.toFixed(2)}</td>
          <td>${o.sacko}</td>
        `;
        tbody.appendChild(row);
      });

    makeTableSortable(document.getElementById("overall-table"));

    const container = document.getElementById("tables-container");
    const sortedYears = Object.keys(seasonMap).sort((a, b) => b - a);
    for (let year of sortedYears) {
      const details = document.createElement("details");
      const summary = document.createElement("summary");
      summary.textContent = `Season ${year}`;
      details.appendChild(summary);

      const table = document.createElement("table");
      table.innerHTML = `
        <thead><tr>
          <th>Owner Name</th>
          <th>Wins</th>
          <th>Losses</th>
          <th>Points For</th>
          <th>Points Against</th>
        </tr></thead>
      `;

      const tbody = document.createElement("tbody");
      [...seasonMap[year]].map(row => {
        const wins = parseInt(row[index.wins]);
        const losses = parseInt(row[index.losses]);
        const pf = parseFloat(row[index.pf]);
        const wp = wins / (wins + losses);
        return { row, wins, losses, pf, wp };
      }).sort((a, b) => b.wp - a.wp || b.pf - a.pf)
        .map((entry, i) => ({ ...entry, rank: i + 1 }))
        .forEach(({ row, rank }) => {
          const ownerDisplay = row[index.ownerName] + (row[index.standing] === "1" ? " *" : "");
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${ownerDisplay}</td>
            <td>${row[index.wins]}</td>
            <td>${row[index.losses]}</td>
            <td>${parseFloat(row[index.pf]).toFixed(2)}</td>
            <td>${parseFloat(row[index.pa]).toFixed(2)}</td>
          `;
          tbody.appendChild(tr);
        });
      table.appendChild(tbody);
      details.appendChild(table);
      container.appendChild(details);
      makeTableSortable(table);
    }
  });

let h2hData = {};
function filterH2H() {
  const owner = document.getElementById("owner-select").value;
  const table = document.getElementById("h2h-table").getElementsByTagName("tbody")[0];
  table.innerHTML = "";

  if (!h2hData[owner]) return;

  const rows = h2hData[owner].map(row => {
    const diff = parseFloat(row["Points For"]) - parseFloat(row["Points Against"]);
    const winPctRaw = parseFloat(row["Win %"]);
    const winPct = isNaN(winPctRaw) ? "0.00%" : (winPctRaw).toFixed(2) + "%";
    return { ...row, "Point Diff": diff.toFixed(2), "Formatted Win %": winPct };
  });

  rows.sort((a, b) => parseInt(b["Games Played"]) - parseInt(a["Games Played"]));
  for (const row of rows) {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row['Opponent Name']}</td>
      <td>${row['Games Played']}</td>
      <td>${row['Wins']}</td>
      <td>${row['Losses']}</td>
      <td>${row['Ties']}</td>
      <td>${parseFloat(row['Points For']).toFixed(2)}</td>
      <td>${parseFloat(row['Points Against']).toFixed(2)}</td>
      <td>${row['Point Diff']}</td>
      <td>${row['Formatted Win %']}</td>
    `;
    table.appendChild(tr);
  }
}

fetch("head_to_head_lifetime.csv")
  .then(response => response.text())
  .then(text => {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",");
    const data = lines.slice(1).map(l => {
      const values = l.split(",");
      const row = {};
      headers.forEach((h, i) => row[h] = values[i]);
      return row;
    });

    const select = document.getElementById("owner-select");
    const seasonCounts = {}, names = {};
    data.forEach(r => {
      if (!seasonCounts[r["Owner Name"]]) {
        seasonCounts[r["Owner Name"]] = 0;
        names[r["Owner Name"]] = r["Owner ID"];
      }
      seasonCounts[r["Owner Name"]]++;
    });

    Object.keys(seasonCounts).filter(k => seasonCounts[k] >= 5).sort().forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.innerText = name;
      select.appendChild(opt);
    });

    for (const row of data) {
      const owner = row["Owner Name"];
      if (!h2hData[owner]) h2hData[owner] = [];
      h2hData[owner].push(row);
    }
    filterH2H();
  });
  makeTableSortable(document.getElementById("h2h-table"));
  let allRecords = [];

fetch("all_time_records.csv")
  .then(response => response.text())
  .then(text => {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",");
    allRecords = lines.slice(1).map(line => {
      const row = line.split(",");
      return {
        Category: row[0],
        Record: row[1],
        Owner: row[2],
        Detail: row[3],
        Points: row[4],
        Year: row[5],
        Week: row[6]
      };
    });

    // Only keep Team Game and Single Game
    allRecords = allRecords.filter(r =>
      r.Category === "Team Game" || r.Category === "Single Game"
    );

    renderRecordsTable(allRecords);
    makeTableSortable(document.getElementById("records-table"));
  });

// Filter and render based on dropdown selection
document.getElementById("category-filter").addEventListener("change", function () {
  const selected = this.value;
  const filtered = selected === "All"
    ? allRecords
    : allRecords.filter(r => r.Category === selected);
  renderRecordsTable(filtered);
});

function renderRecordsTable(records) {
  const tbody = document.querySelector("#records-table tbody");
  tbody.innerHTML = "";
  records.forEach(record => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${record.Category}</td>
      <td>${record.Record}</td>
      <td>${record.Owner}</td>
      <td>${record.Detail}</td>
      <td>${record.Points}</td>
      <td>${record.Year}</td>
      <td>${record.Week}</td>
    `;
    tbody.appendChild(tr);
  });
}
fetch("weekly_payout_winners.csv")
  .then(response => response.text())
  .then(text => {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",");
    const rows = lines.slice(1).map(line => line.split(","));
    const payoutTbody = document.querySelector("#payouts-table tbody");
    const leaderboardTbody = document.querySelector("#season-leaderboard tbody");

    const ownerTotals = {};

    rows.forEach(row => {
      if (row.length < 5 || !row[0]) return;

      const [week, award, winner, players, points] = row;

      // Populate payouts table
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${week}</td>
        <td>${award}</td>
        <td>${winner}</td>
        <td>${players}</td>
        <td>${points}</td>
      `;
      payoutTbody.appendChild(tr);

      // Tally for leaderboard
      if (!ownerTotals[winner]) {
        ownerTotals[winner] = 0;
      }
      ownerTotals[winner] += 1; // If payout value varies, replace with actual value
    });

    // Populate leaderboard table
    Object.entries(ownerTotals)
      .sort((a, b) => b[1] - a[1])
      .forEach(([owner, total]) => {
        const row = document.createElement("tr");
        row.innerHTML = `<td>${owner}</td><td>${total}</td>`;
        leaderboardTbody.appendChild(row);
      });

    makeTableSortable(document.getElementById("payouts-table"));
    makeTableSortable(document.getElementById("season-leaderboard"));
  });
  fetch("most_drafted_players.csv")
  .then(response => response.text())
  .then(text => {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",");
    const rows = lines.slice(1).map(line => line.split(","));

    const tbody = document.querySelector("#habits-table tbody");
    for (const row of rows) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${row[1]}</td> <!-- Owner Name -->
        <td>${row[2]}</td> <!-- Most Drafted Player -->
        <td>${row[3]}</td> <!-- Times Drafted -->
        <td>${row[4]}</td> <!-- Drafted Seasons -->
      `;
      tbody.appendChild(tr);
    }

    makeTableSortable(document.getElementById("habits-table"));
  });

  fetch("positional_contributions.csv")
  .then(response => response.text())
  .then(text => {
    const { headers, rows } = parseCSV(text);
    const index = {
      year: headers.indexOf("Year"),
      name: headers.indexOf("Owner Name"),
      total: headers.indexOf("Total Points"),
      qb: headers.indexOf("QB %"),
      rb: headers.indexOf("RB %"),
      wr: headers.indexOf("WR %"),
      te: headers.indexOf("TE %"),
      k: headers.indexOf("K %"),
      dst: headers.indexOf("D/ST %")
    };

    const seasonMap = {}, overallMap = {};

    for (const row of rows) {
      const year = row[index.year];
      if (!seasonMap[year]) seasonMap[year] = [];
      seasonMap[year].push(row);

      const name = row[index.name];
      if (!overallMap[name]) {
        overallMap[name] = { count: 0, total: 0, qb: 0, rb: 0, wr: 0, te: 0, k: 0, dst: 0 };
      }
      const o = overallMap[name];
      o.count++;
      o.total += parseFloat(row[index.total]);
      o.qb += parseFloat(row[index.qb]);
      o.rb += parseFloat(row[index.rb]);
      o.wr += parseFloat(row[index.wr]);
      o.te += parseFloat(row[index.te]);
      o.k += parseFloat(row[index.k]);
      o.dst += parseFloat(row[index.dst]);
    }

    const overallTbody = document.querySelector("#position-overall-table tbody");
    Object.entries(overallMap).forEach(([owner, data]) => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${owner}</td>
        <td>${data.total.toFixed(2)}</td>
        <td>${(data.qb / data.count).toFixed(2)}%</td>
        <td>${(data.rb / data.count).toFixed(2)}%</td>
        <td>${(data.wr / data.count).toFixed(2)}%</td>
        <td>${(data.te / data.count).toFixed(2)}%</td>
        <td>${(data.k / data.count).toFixed(2)}%</td>
        <td>${(data.dst / data.count).toFixed(2)}%</td>
      `;
      overallTbody.appendChild(tr);
    });

    makeTableSortable(document.getElementById("position-overall-table"));

    const container = document.getElementById("position-seasons-container");
    const sortedYears = Object.keys(seasonMap).sort((a, b) => b - a);
    for (const year of sortedYears) {
      const details = document.createElement("details");
      const summary = document.createElement("summary");
      summary.textContent = `Season ${year}`;
      details.appendChild(summary);

      const table = document.createElement("table");
      table.innerHTML = `
        <thead>
          <tr>
            <th>Owner</th>
            <th>Total Points</th>
            <th>QB %</th>
            <th>RB %</th>
            <th>WR %</th>
            <th>TE %</th>
            <th>K %</th>
            <th>D/ST %</th>
          </tr>
        </thead>
      `;

      const tbody = document.createElement("tbody");
      for (const row of seasonMap[year]) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row[index.name]}</td>
          <td>${parseFloat(row[index.total]).toFixed(2)}</td>
          <td>${parseFloat(row[index.qb]).toFixed(2)}%</td>
          <td>${parseFloat(row[index.rb]).toFixed(2)}%</td>
          <td>${parseFloat(row[index.wr]).toFixed(2)}%</td>
          <td>${parseFloat(row[index.te]).toFixed(2)}%</td>
          <td>${parseFloat(row[index.k]).toFixed(2)}%</td>
          <td>${parseFloat(row[index.dst]).toFixed(2)}%</td>
        `;
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      details.appendChild(table);
      container.appendChild(details);
      makeTableSortable(table);
    }
  });

fetch("advanced_team_metrics.csv")
  .then(response => response.text())
  .then(text => {
    const { headers, rows } = parseCSV(text);
    const index = {
      year: headers.indexOf("Year"),
      name: headers.indexOf("Owner Name"),
      truew: headers.indexOf("Normalized True Wins"),
      truel: headers.indexOf("Normalized True Losses"),
      truewl: headers.indexOf("True W/L"),
      truewlpct: headers.indexOf("True W/L %"),
      luck: headers.indexOf("Luck Index"),
      sos: headers.indexOf("Strength of Schedule"),
      eff: headers.indexOf("Manager Efficiency")
    };

    const seasonMap = {}, overallMap = {};

    for (const row of rows) {
      const year = row[index.year];
      if (!seasonMap[year]) seasonMap[year] = [];
      seasonMap[year].push(row);

      const name = row[index.name];
      if (!overallMap[name]) {
        overallMap[name] = {
          count: 0, truew: 0, truel: 0, luck: 0, sos: 0, eff: 0
        };
      }
      console.log("Normalized Wins:", row[index.truew], "Losses:", row[index.truel]);
      const o = overallMap[name];
      o.count++;
      o.truew += parseFloat(row[index.truew]);
      o.truel += parseFloat(row[index.truel]);
      o.luck += parseFloat(row[index.luck]);
      o.sos += parseFloat(row[index.sos]);
      o.eff += parseFloat(row[index.eff]);
    }

    const overallTbody = document.querySelector("#advanced-overall-table tbody");
    Object.entries(overallMap).forEach(([owner, data]) => {
      if (data.count < 3) return;
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${owner}</td>
        <td>${data.truew} - ${data.truel}</td>
        <td>${(data.truew / (data.truew + data.truel)).toFixed(3)}</td>
        <td>${(data.luck / data.count).toFixed(3)}</td>
        <td>${(data.sos / data.count).toFixed(2)}</td>
        <td>${(data.eff / data.count).toFixed(3)}</td>
      `;
      overallTbody.appendChild(tr);
    });
    makeTableSortable(document.getElementById("advanced-overall-table"));

    const container = document.getElementById("advanced-seasons-container");
    const sortedYears = Object.keys(seasonMap).sort((a, b) => b - a);
    for (const year of sortedYears) {
      const details = document.createElement("details");
      const summary = document.createElement("summary");
      summary.textContent = `Season ${year}`;
      details.appendChild(summary);

      const table = document.createElement("table");
      table.innerHTML = `
        <thead>
          <tr>
            <th>Owner</th>
            <th>True W/L</th>
            <th>True W/L %</th>
            <th>Luck Index</th>
            <th>Strength of Schedule</th>
            <th>Manager Efficiency</th>
          </tr>
        </thead>
      `;

      const tbody = document.createElement("tbody");
      for (const row of seasonMap[year]) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row[index.name]}</td>
          <td>${row[index.truewl]}</td>
          <td>${row[index.truewlpct]}</td>
          <td>${row[index.luck]}</td>
          <td>${parseFloat(row[index.sos]).toFixed(2)}</td>
          <td>${parseFloat(row[index.eff]).toFixed(3)}</td>
        `;
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      details.appendChild(table);
      container.appendChild(details);
      makeTableSortable(table);
    }
  });
  Promise.all([
  fetch("weekly_efficiency_awards.csv").then(res => res.text()),
  fetch("survivor_results.json").then(res => res.json()),
  fetch("weekly_payout_winners.json").then(res => res.json())
])
.then(([awardsText, survivorData, payoutData]) => {
const lines = awardsText.trim().split("\n");
const headers = lines[0].split(",");
const rows = lines.slice(1).map(line => line.split(","));

const payoutByWeek = {};
for (const payout of payoutData) {
  const week = payout.week;
  if (!payoutByWeek[week]) payoutByWeek[week] = [];
  payoutByWeek[week].push(payout);
}


const index = {
week: headers.indexOf("Week"),
owner: headers.indexOf("Owner"),
award: headers.indexOf("Award")
};

const survivorList = document.getElementById("survivor-list");
survivorData.remaining
  .sort()
  .forEach(owner => {
    const li = document.createElement("li");
    li.textContent = owner;
    survivorList.appendChild(li);
  });


const weekMap = {};
for (const row of rows) {
const week = row[index.week];
const award = row[index.award];
if (!award || !week) continue;


if (!weekMap[week]) weekMap[week] = [];
weekMap[week].push({ award, owner: row[index.owner] });
}


const eliminatedByWeek = {};
for (const owner in survivorData.eliminated) {
const week = survivorData.eliminated[owner];
if (!eliminatedByWeek[week]) eliminatedByWeek[week] = [];
eliminatedByWeek[week].push(owner);
}


const container = document.getElementById("summaries-container");
const sortedWeeks = Object.keys(weekMap).map(Number).sort((a, b) => b - a);


for (const week of sortedWeeks) {
const details = document.createElement("details");
const summary = document.createElement("summary");
summary.textContent = `Week ${week}`;
details.appendChild(summary);


const list = document.createElement("ul");


if (eliminatedByWeek[week]) {
const elimList = eliminatedByWeek[week].join(", ");
const li = document.createElement("li");
li.innerHTML = `ðŸ’€ <strong>Survivor:</strong> Eliminated: ${elimList}`;
list.appendChild(li);
}

if (payoutByWeek[week]) {
  for (const payout of payoutByWeek[week]) {
    const li = document.createElement("li");
    li.innerHTML = `ðŸ’° <strong>${payout.payout_text}:</strong> ${payout.owner} (${payout.points} pts)`;
    list.appendChild(li);
  }
}


for (const entry of weekMap[week]) {
const li = document.createElement("li");
li.innerHTML = `${entry.award}: <strong>${entry.owner}</strong>`;
list.appendChild(li);
}


details.appendChild(list);
container.appendChild(details);
}

// --- Build Summary Overview ---
const summaryCounts = {};

// Payouts
payoutData.forEach(entry => {
  const owner = entry.owner;
  if (!summaryCounts[owner]) summaryCounts[owner] = { payouts: 0, regression: 0, crawlspace: 0, clipboard: 0 };
  summaryCounts[owner].payouts++;
});

// Awards
rows.forEach(row => {
  const owner = row[index.owner];
  const award = row[index.award];
  if (!owner || !award) return;

  if (!summaryCounts[owner]) summaryCounts[owner] = { payouts: 0, regression: 0, crawlspace: 0, clipboard: 0 };

  if (award.includes("Regression")) summaryCounts[owner].regression++;
  else if (award.includes("Crawlspace")) summaryCounts[owner].crawlspace++;
  else if (award.includes("Clipboard")) summaryCounts[owner].clipboard++;
});

// Survivor exits
for (const [owner, week] of Object.entries(survivorData.eliminated)) {
  if (!summaryCounts[owner]) summaryCounts[owner] = { payouts: 0, regression: 0, crawlspace: 0, clipboard: 0 };
  summaryCounts[owner].eliminated = week;
}
// Remaining survivor players (not eliminated)
survivorData.remaining.forEach(owner => {
  if (!summaryCounts[owner]) summaryCounts[owner] = { payouts: 0, regression: 0, crawlspace: 0, clipboard: 0 };
  summaryCounts[owner].eliminated = "Still Alive";
});

// Render table
const summaryTable = document.querySelector("#weekly-summary-overview tbody");
Object.entries(summaryCounts)
  .sort((a, b) => a[0].localeCompare(b[0]))
  .forEach(([owner, stats]) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${owner}</td>
      <td>${stats.payouts || 0}</td>
      <td>${stats.eliminated ?? "â€”"}</td>
      <td>${stats.regression || 0}</td>
      <td>${stats.crawlspace || 0}</td>
      <td>${stats.clipboard || 0}</td>
    `;
    summaryTable.appendChild(tr);
  });
  makeTableSortable(document.getElementById("weekly-summary-overview"));
});
</script>
</body>
</html>
